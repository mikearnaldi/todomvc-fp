{"version":3,"sources":["serviceWorker.ts","modules/dom.ts","modules/fetch.ts","modules/store.ts","modules/emitter.ts","modules/document.ts","modules/todo.ts","index.ts"],"names":["Boolean","window","location","hostname","match","eventType","input","init","tagName","options","initial","rootEl","uri","subscribe","type","ret","el","S","fromSource","M","managed","chain","bracket","T","accessM","_","sync","su","queueUtils","next","ops","hasCB","unsubscribe","addEventListener","fromEvent","fn","a","_tag","emitter","documentLive","document","provideDocument","provide","getDocument","flow","pure","domLive","createElement","provideDom","ElementNotFound","selectors","name","Error","ParentElementNotFound","child","makeElementNotFound","makeParentElementNotFound","raiseError","element","toString","querySelector","O","$","pipe","map","fromOption","constant","parentElement","node","EmptyOptionOfElement","message","fetchLive","fetch","bind","provideFetch","FetchFailed","info","makeFetchFailed","url","error","todoDecoder","t","id","userId","title","completed","todosDecoder","fetchTodos","async","r","then","response","json","E","cb","decode","fromEither","_div","todosStore","Q","unboundedQueue","zip","ref","makeRef","queue","state","f","update","current","offer","take","some","createTodoLi","innerHTML","todosUl","clearTodosUl","ul","renderTodos","todos","A","todo","todoLi","Do","return","label","setAttribute","classList","add","checked","identity","updateTodoLi","sequence","effect","list","forEach","li","appendChild","main","store","parZip","fork","encaseEffect","drain","target","hasAttribute","div","parent","getAttribute","Number","todoId","filter","constVoid","forever","provided","Todo","Fetch","provideConsole","e","stopPropagation","removeEventListener","AsyncRTURI","runToPromise","foo","console","log","catch","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.7c96c4b8.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL || '',\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import { effect as T, stream as S } from \"@matechs/effect\";\r\nimport * as O from \"fp-ts/lib/Option\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { constant, flow, identity } from \"fp-ts/lib/function\";\r\nimport { subscribe, Emitter, EventFor } from \"./emitter\";\r\nimport { AsyncRT } from \"@matechs/effect/lib/effect\";\r\nimport { DocumentEnv, getDocument } from \"./document\";\r\n\r\n/**\r\n * Environment\r\n */\r\nexport const uri = \"@uri/dom\";\r\n\r\nexport interface Dom {\r\n  [uri]: {\r\n    createElement<K extends keyof HTMLElementTagNameMap>(\r\n      tagName: K,\r\n      options?: ElementCreationOptions\r\n    ): HTMLElementTagNameMap[K];\r\n    createElement(\r\n      tagName: string,\r\n      options?: ElementCreationOptions\r\n    ): HTMLElement;\r\n  };\r\n}\r\n\r\nexport const domLive: Dom = {\r\n  [uri]: {\r\n    createElement: (tagName: any, options?: ElementCreationOptions) =>\r\n      document.createElement(tagName, options),\r\n  },\r\n};\r\n\r\nexport const provideDom = T.provide(domLive)\r\n\r\n/**\r\n * Errors\r\n */\r\nclass ElementNotFound extends Error {\r\n    constructor(selectors: string) {\r\n      super(`$(${selectors}) did not return an element.`);\r\n      this.name = \"ElementNotFound\";\r\n    }\r\n  }\r\n  \r\n  class ParentElementNotFound extends Error {\r\n    constructor(child: string) {\r\n      super(`Parent of node: ${child} not found.`);\r\n      this.name = \"ParentElementNotFound\";\r\n    }\r\n  }\r\n  \r\n  export const makeElementNotFound = (selectors: string) =>\r\n    new ElementNotFound(selectors);\r\n  \r\n  export const raiseElementNotFound = flow(makeElementNotFound, T.raiseError);\r\n  \r\n  export const makeParentElementNotFound = (element: HTMLElement) =>\r\n    new ParentElementNotFound(element.toString());\r\n  \r\n  export const raiseParentElementNotFound = flow(\r\n    makeParentElementNotFound,\r\n    T.raiseError\r\n  );\r\n\r\n/**\r\n * Utilities\r\n */\r\ninterface CreateElement {\r\n  <K extends keyof HTMLElementTagNameMap>(\r\n    tagName: K,\r\n    options?: ElementCreationOptions\r\n  ): T.Effect<Dom, never, HTMLElementTagNameMap[K]>;\r\n  (tagName: string, options?: ElementCreationOptions): T.Effect<\r\n    Dom,\r\n    never,\r\n    HTMLElement\r\n  >;\r\n}\r\n\r\nexport const createElement: CreateElement = (\r\n  tagName: string,\r\n  options?: ElementCreationOptions\r\n) => T.accessM((_: Dom) => T.pure(_[uri].createElement(tagName, options)));\r\n\r\n/**\r\n * QuerySelector\r\n */\r\ninterface QuerySelector {\r\n  <K extends keyof HTMLElementTagNameMap>(selectors: K): <\r\n    TNode extends ParentNode\r\n  >(\r\n    node: TNode\r\n  ) => O.Option<HTMLElementTagNameMap[K]>;\r\n  <K extends keyof SVGElementTagNameMap>(selectors: K): <\r\n    TNode extends ParentNode\r\n  >(\r\n    node: TNode\r\n  ) => O.Option<SVGElementTagNameMap[K]>;\r\n  <E extends Element = Element>(selectors: string): <TNode extends ParentNode>(\r\n    node: TNode\r\n  ) => O.Option<E>;\r\n}\r\n\r\ninterface QuerySelectorT {\r\n  <K extends keyof HTMLElementTagNameMap>(selectors: K): <\r\n    TNode extends ParentNode\r\n  >(\r\n    node: O.Option<TNode>\r\n  ) => O.Option<HTMLElementTagNameMap[K]>;\r\n  <K extends keyof SVGElementTagNameMap>(selectors: K): <\r\n    TNode extends ParentNode\r\n  >(\r\n    node: O.Option<TNode>\r\n  ) => O.Option<SVGElementTagNameMap[K]>;\r\n  <E extends Element = Element>(selectors: string): <TNode extends ParentNode>(\r\n    node: O.Option<TNode>\r\n  ) => O.Option<E>;\r\n}\r\n\r\nexport const querySelector: QuerySelector = (selectors: string) => <\r\n  TNode extends ParentNode\r\n>(\r\n  el: TNode\r\n) => O.fromNullable(el.querySelector(selectors));\r\n\r\nexport const querySelectorO: QuerySelectorT = (selectors: string) => <\r\n  TNode extends ParentNode\r\n>(\r\n  nodeOT: O.Option<TNode>\r\n) =>\r\n  pipe(\r\n    nodeOT,\r\n    O.map((el) => querySelector(selectors)(el))\r\n  );\r\n\r\n/**\r\n * $\r\n */\r\ninterface $ {\r\n  <K extends keyof HTMLElementTagNameMap>(selectors: K): T.Effect<\r\n    DocumentEnv,\r\n    ElementNotFound,\r\n    HTMLElementTagNameMap[K]\r\n  >;\r\n  <K extends keyof SVGElementTagNameMap>(selectors: K): T.Effect<\r\n    DocumentEnv,\r\n    ElementNotFound,\r\n    SVGElementTagNameMap[K]\r\n  >;\r\n  <E extends Element = Element>(selectors: string): T.Effect<\r\n    DocumentEnv,\r\n    ElementNotFound,\r\n    E\r\n  >;\r\n}\r\n\r\nexport const $: $ = (selectors: string) =>\r\n  pipe(\r\n    getDocument,\r\n    T.map(querySelector(selectors)),\r\n    T.chain(T.fromOption(constant(makeElementNotFound(selectors))))\r\n  );\r\n\r\n/**\r\n * ```hs\r\n * parentElement :: Node -> Option<HTMLelement>\r\n * ```\r\n */\r\nexport const parentElement = <TNode extends Node, TParentNode extends Node>(\r\n  node: TNode\r\n) => O.fromNullable(node.parentElement as TParentNode | null);\r\n\r\nexport class EmptyOptionOfElement extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = \"EmptyOptionOfElement\";\r\n  }\r\n}\r\n\r\nexport const raiseEmptyOptionOfElement = (message: string) =>\r\n  T.raiseError(new EmptyOptionOfElement(message));\r\n\r\nexport const makeEventStream = <TEventType extends string>(\r\n  eventType: TEventType\r\n) => <R, E, A extends Element>(elementT: T.Effect<R, E, O.Option<A>>) =>\r\n  pipe(\r\n    elementT,\r\n    T.map((elementO) =>\r\n      pipe(\r\n        elementO,\r\n        O.map(subscribe(eventType)),\r\n        O.fold<\r\n          S.Stream<Emitter & AsyncRT, never, EventFor<TEventType>>,\r\n          S.Stream<\r\n            Emitter & AsyncRT,\r\n            EmptyOptionOfElement,\r\n            EventFor<TEventType>\r\n          >\r\n        >(\r\n          constant(\r\n            S.raised(\r\n              new EmptyOptionOfElement(\r\n                `Option does not contain some element to create ${eventType} event stream for`\r\n              )\r\n            )\r\n          ),\r\n          identity\r\n        )\r\n      )\r\n    )\r\n  );\r\n\r\nexport const makeClickStream = makeEventStream(\"click\");\r\n","import { effect as T } from \"@matechs/effect\";\r\nimport * as E from \"fp-ts/lib/Either\";\r\nimport { flow } from \"fp-ts/lib/function\";\r\n\r\nexport const uri = \"@uri/fetch\";\r\n\r\nexport interface Fetch {\r\n  [uri]: {\r\n    fetch: typeof window.fetch;\r\n  }\r\n}\r\n\r\nexport const fetchLive: Fetch = {\r\n  [uri]: {\r\n    fetch: window.fetch.bind(window)\r\n  },\r\n};\r\n\r\nexport const provideFetch = T.provide(fetchLive)\r\n\r\nclass FetchFailed extends Error {\r\n    constructor(info: string) {\r\n      super(`Unable to fetch: ${info}`);\r\n      this.name = \"FetchFailed\";\r\n    }\r\n  }\r\n\r\nconst makeFetchFailed = (url: string) => (error: string) => new FetchFailed(\r\n    `Fetching data from `\r\n)\r\n\r\nexport const fetch = (input: RequestInfo, init?: RequestInit) =>\r\n  T.accessM((_: Fetch) =>\r\n    T.async<FetchFailed, Response>((r) => {\r\n      try {\r\n        _[uri].fetch(input, init).then(response => response.json()).then(flow(E.right, r));\r\n      } catch (error) {\r\n        r(E.left(makeFetchFailed(typeof input === 'string' ? input : input.url)(error)));\r\n      }\r\n\r\n      return (cb) => {\r\n        cb(makeFetchFailed(typeof input === 'string' ? input : input.url)(\"\"));\r\n      };\r\n    })\r\n  );\r\n","import {\r\n  effect as T,\r\n  ref,\r\n  stream as S,\r\n  queue as Q,\r\n  managed as M,\r\n} from \"@matechs/effect\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { some } from \"fp-ts/lib/Option\";\r\n\r\nexport type Store<A> = {\r\n    next: (f: (current: A) => A) => T.Effect<T.AsyncRT, never, void>,\r\n    subscribe: S.Stream<T.AsyncRT, never, A>\r\n}\r\n\r\nexport const store = <A>(initial?: A) =>\r\n  pipe(\r\n    Q.unboundedQueue<A>(),\r\n    T.zip(ref.makeRef(initial ? [initial] : [])),\r\n    T.map(([queue, state]): Store<A> => {\r\n      const next = (f: (current: A) => A) =>\r\n        pipe(\r\n            state.update(([current]) => [f(current)]),\r\n            T.chain(([a]) => queue.offer(a))\r\n        );\r\n\r\n      const subscribe = pipe(\r\n        S.fromSource(M.pure(pipe(queue.take, T.map(some))))\r\n      );\r\n      return { next, subscribe }\r\n    })\r\n  );\r\n","import { effect as T, stream as S, managed as M } from \"@matechs/effect\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { log } from \"@matechs/console\";\r\nimport { AsyncRT } from \"@matechs/effect/lib/effect\";\r\n\r\nexport const uri = \"@uri/emitter\";\r\n\r\nexport type EventFor<TEventType extends string> = TEventType extends\r\n  | \"keypress\"\r\n  | \"keyup\"\r\n  | \"keydown\"\r\n  ? KeyboardEvent\r\n  : TEventType extends \"click\" | \"dblclick\" | \"mousemove\" | \"mousedown\" | \"mouseup\"\r\n  ? MouseEvent\r\n  : Event;\r\n\r\nexport type EventHandler<TEventType extends string> = (\r\n  evt: EventFor<TEventType>\r\n) => void;\r\n\r\nexport interface Emitter {\r\n  [uri]: {\r\n    fromEvent: <TEventType extends string>(\r\n      type: TEventType\r\n    ) => (cb: EventHandler<TEventType>) => T.Effect<T.NoEnv, never, void>;\r\n    addEventListener: <TElement extends Pick<Element, 'addEventListener' | 'removeEventListener'>>(\r\n      el: TElement\r\n    ) => <TEventType extends string>(\r\n      type: TEventType\r\n    ) => (cb: EventHandler<TEventType>) => T.Effect<T.NoEnv, never, void>;\r\n  };\r\n}\r\n\r\n// Events\r\nexport const subscribe = <TEventType extends string>(type: TEventType, ret?: any) => <\r\n  TElement extends  Pick<Element, 'addEventListener' | 'removeEventListener'>\r\n>(\r\n  el?: TElement\r\n) => {\r\n  return S.fromSource(\r\n    M.managed.chain(\r\n      M.bracket(\r\n        T.accessM((_: Emitter & AsyncRT) =>\r\n          T.sync(() => {\r\n            const { next, ops, hasCB } = S.su.queueUtils<\r\n              never,\r\n              EventFor<TEventType>\r\n            >();\r\n\r\n            const fn = el ? _[uri].addEventListener(el) : _[uri].fromEvent;\r\n\r\n            return {\r\n              unsubscribe: fn(type)(a => {\r\n                next({ _tag: \"offer\", a })\r\n                return ret\r\n              }),\r\n              ops,\r\n              hasCB\r\n            };\r\n          })\r\n        ),\r\n        _ => _.unsubscribe\r\n      ),\r\n      ({ ops, hasCB }) => S.su.emitter(ops, hasCB)\r\n    )\r\n  );\r\n};\r\n\r\nexport const makeEmitterLive = <\r\n  TRoot extends Pick<Element, \"addEventListener\" | \"removeEventListener\">\r\n>(\r\n  rootEl: TRoot\r\n): Emitter => {\r\n  return {\r\n    [uri]: {\r\n      fromEvent: <TEventType extends string>(type: TEventType) => (\r\n        cb: EventHandler<TEventType>\r\n      ) => {\r\n        const wrappedCb = (e: EventFor<TEventType>) => {\r\n          e.stopPropagation();\r\n          return cb(e);\r\n        };\r\n        rootEl.addEventListener(type, wrappedCb as any);\r\n\r\n        return T.sync(() => rootEl.removeEventListener(type, cb as any));\r\n      },\r\n      addEventListener: <TElement extends Pick<Element, 'addEventListener' | 'removeEventListener'>>(el: TElement) => <\r\n        TEventType extends string\r\n      >(\r\n        type: TEventType\r\n      ) => (cb: EventHandler<TEventType>) => {\r\n        const wrappedCb = (e: EventFor<TEventType>) => {\r\n          e.stopPropagation();\r\n          return cb(e);\r\n        };\r\n        el.addEventListener(type, wrappedCb as any);\r\n\r\n        return T.sync(() => el.removeEventListener(type, cb as any));\r\n      }\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * waitForKeyPress :: number -> Effect NoEnv never void\r\n *\r\n * Given a keyCode returns an effect that resolves once the user\r\n * presses a key on the keyboard matching the key code.\r\n */\r\nexport const waitForKeyPress = (...keyCodes: number[]) =>\r\n  T.effect.chain(log(\"Waiting for \", ...keyCodes), () =>\r\n    pipe(\r\n      subscribe(\"keyup\")(),\r\n      S.filter(event => keyCodes.includes(event.keyCode)),\r\n      S.take(1),\r\n      S.collectArray,\r\n      T.map(([evt]) => evt)\r\n    )\r\n  );\r\n","import { effect as T } from \"@matechs/effect\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport {  flow } from \"fp-ts/lib/function\";\r\n\r\nexport const documentUri = \"@uri/document\";\r\n\r\nexport type DocumentEnv = { [documentUri]: Document };\r\n\r\nexport const documentLive = {\r\n  [documentUri]: document,\r\n};\r\n\r\nexport const provideDocument = T.provide(documentLive);\r\n\r\nexport const getDocument = T.accessM(\r\n  flow((_: DocumentEnv) => _[documentUri], T.pure)\r\n);\r\n\r\nexport const mapDocument = <R, E, A>(f: (doc: Document) => T.Effect<R, E, A>) =>\r\n  pipe(getDocument, T.map(f));\r\n","import { effect as T, stream as S } from \"@matechs/effect\";\r\n\r\nimport * as O from \"fp-ts/lib/Option\";\r\nimport * as A from \"fp-ts/lib/Array\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { constant, identity, flow, constVoid } from \"fp-ts/lib/function\";\r\n\r\nimport * as t from \"io-ts\";\r\nimport { Do } from \"fp-ts-contrib/lib/Do\";\r\n\r\nimport {\r\n  createElement,\r\n  querySelector,\r\n  makeElementNotFound,\r\n  $,\r\n  parentElement,\r\n  makeParentElementNotFound,\r\n} from \"./dom\";\r\nimport * as Fetch from \"./fetch\";\r\nimport { store } from \"./store\";\r\nimport { subscribe } from \"./emitter\";\r\n\r\n/**\r\n * ```hs\r\n *\r\n * URL :: string\r\n *\r\n * ```\r\n *\r\n * API URL where a list of todo objects is requested from\r\n */\r\nconst URL = \"https://jsonplaceholder.typicode.com/todos\";\r\n\r\n/**\r\n * ```hs\r\n *\r\n * Todo :: t.TypeC<Todo>\r\n *\r\n * ```\r\n *\r\n * io-ts decoder for Todo\r\n */\r\nconst todoDecoder = t.type(\r\n  {\r\n    id: t.number,\r\n    userId: t.number,\r\n    title: t.string,\r\n    completed: t.boolean,\r\n  },\r\n  \"Todo\"\r\n);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * Todos :: t.TypeC<Todos>\r\n *\r\n * ```\r\n *\r\n * io-ts decoder for a list of [[Todo]]\r\n */\r\nconst todosDecoder = t.array(todoDecoder);\r\n\r\n// Types\r\nexport type Todo = t.TypeOf<typeof todoDecoder>;\r\n\r\nexport type Todos = t.TypeOf<typeof todosDecoder>;\r\n\r\n// APIS\r\nexport const fetchTodos = pipe(\r\n  // Fetch list of todos from the server\r\n  Fetch.fetch(URL),\r\n  // Decode the response\r\n  T.chain((response) => T.sync(() => todosDecoder.decode(response))),\r\n  // From Effect<R, E, Either<E2, Todos> to Effect<R, E | E2, Todos>\r\n  T.chain(T.fromEither)\r\n);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * html :: string\r\n *\r\n * ```\r\n *\r\n * HTML used to create a todo for\r\n */\r\nconst html = `<li>\r\n    <div class=\"view\">\r\n        <input data-toggle class=\"toggle\" type=\"checkbox\">\r\n        <label data-edit>Buy a unicorn</label>\r\n        <button data-remove class=\"destroy\"></button>\r\n    </div>\r\n    <input class=\"edit\" value=\"Rule the web\">\r\n</li>`;\r\n\r\n// TODO: Use environment to produce div\r\nconst _div = createElement(\"div\");\r\n\r\n/**\r\n * ```hs\r\n *\r\n * todosStore :: Effect unknown never (Store Todos)\r\n *\r\n * ```\r\n *\r\n * You can update the list of todos by passing a callback function to store.next\r\n * or subscribe to store changes using the store.subscribe stream.\r\n */\r\nexport const todosStore = store<Todos>();\r\n\r\n/**\r\n * ```hs\r\n *\r\n * createTodoLi :: Effect Dom ElementNotFound HTMLLIElement\r\n *\r\n * ```\r\n *\r\n * Create a dom element for a todo\r\n */\r\nexport const createTodoLi = pipe(\r\n  _div,\r\n  T.chain((el) =>\r\n    T.sync(() => {\r\n      el.innerHTML = html;\r\n      return querySelector(\"li\")(el);\r\n    })\r\n  ),\r\n  T.chain(\r\n    T.fromOption(\r\n      constant(\r\n        makeElementNotFound(\"Unable to create DOM element for todo item.\")\r\n      )\r\n    )\r\n  )\r\n);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * todosUl :: Effect DocumentEnv ElementNotFound HTMLUListElement\r\n *\r\n * ```\r\n *\r\n * Select the ul dom node that contains the list of li nodes that are todo items.\r\n */\r\nexport const todosUl = $<HTMLUListElement>(\".todo-list\");\r\n\r\nexport const clearTodosUl = pipe(\r\n  todosUl,\r\n  T.chain((ul) =>\r\n    T.sync(() => {\r\n      ul.innerHTML = \"\";\r\n    })\r\n  )\r\n);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * updateTodoLi :: Todo -> HTMLLIElement -> Effect unknown Error HTMLLIElement\r\n *\r\n * ```\r\n *\r\n * Update a given todo dom li node with information from a [[Todo]] model\r\n */\r\nexport const updateTodoLi = (todo: Todo) => (todoLi: HTMLLIElement) =>\r\n  pipe(\r\n    Do(O.option)\r\n      // Select the input and label dom nodes that are inside the li node\r\n      .bind(\"label\", querySelector(\"label\")(todoLi))\r\n      .bind(\"input\", querySelector(\"input\")(todoLi))\r\n      .return(({ label, input }) =>\r\n        T.sync(() => {\r\n          // Update title\r\n          label.innerHTML = todo.title;\r\n\r\n          // Add todo id as attribute\r\n          todoLi.setAttribute(\"data-todo-id\", \"\" + todo.id);\r\n\r\n          // Mark as completed if so\r\n          todo.completed && todoLi.classList.add(\"completed\");\r\n          input.checked = todo.completed;\r\n\r\n          return todoLi;\r\n        })\r\n      ),\r\n    // TODO: Handle if label or input aren't available\r\n    T.fromOption(constant(Error(\"\"))),\r\n    T.chain(identity)\r\n  );\r\n\r\n/**\r\n * ```hs\r\n *\r\n * renderTodos :: [Todo] -> Effect (DocumentEnv & Dom) (Error | ElementNotFound) (void, HTMLUListElement)\r\n *\r\n * ```\r\n *\r\n * Clear the ul dom node and re-render the list of li todo items.\r\n *\r\n */\r\nexport const renderTodos = (todos: Todos) =>\r\n  T.zip(\r\n    pipe(\r\n      todos,\r\n      A.map((todo) => pipe(createTodoLi, T.chain(updateTodoLi(todo)))),\r\n      A.array.sequence(T.effect),\r\n      T.chain((list) =>\r\n        pipe(\r\n          $<HTMLUListElement>(\".todo-list\"),\r\n          T.chain((ul) =>\r\n            T.sync(() => {\r\n              list.forEach((li) => ul.appendChild(li));\r\n              return ul;\r\n            })\r\n          )\r\n        )\r\n      )\r\n    )\r\n  )(clearTodosUl);\r\n\r\n/**\r\n * The main event\r\n */\r\nexport const main = pipe(\r\n  pipe(\r\n      // Use the store\r\n    todosStore,\r\n    T.chain((store) =>\r\n      T.parZip(\r\n          // Fetch todos and subscribe to the store for updates and re-render\r\n        pipe(\r\n            // Fetch todos from the sever\r\n          fetchTodos,\r\n          // Put items in the store\r\n          T.chain(flow(constant, store.next)),\r\n          // Fork fetching todos \r\n          T.fork,\r\n          T.chain(\r\n            constant(\r\n              pipe(\r\n                  // Subscribe to the store\r\n                store.subscribe,\r\n                // Only take 10 items at a time\r\n                S.map((list) => pipe(list, A.takeLeft(10))),\r\n                // Update the DOM\r\n                S.chain(flow(renderTodos, S.encaseEffect)),\r\n                S.drain\r\n              )\r\n            )\r\n          )\r\n        ),\r\n        // Subscribe to click events in the list and take the appropriate action\r\n        pipe(\r\n            // With the dom node that is the lisf items\r\n          todosUl,\r\n          S.encaseEffect,\r\n          // Subscribe to clicking the list\r\n          S.chain(subscribe(\"click\")),\r\n          // Map the mouse event to the target (currentTarget would be the list, we want what the user actually clicked.)\r\n          S.map((_) => _.target),\r\n          S.map(O.fromNullable),\r\n          S.chain(S.fromOption),\r\n          S.chain((_) => {\r\n            const target = _ as HTMLElement;\r\n\r\n            // If the clicked the remove button\r\n            if (target.hasAttribute(\"data-remove\")) {\r\n              return pipe(\r\n                parentElement<HTMLElement, HTMLDivElement>(target),\r\n                O.chain((div) =>\r\n                  parentElement<HTMLDivElement, HTMLLIElement>(div)\r\n                ),\r\n                T.pure,\r\n                T.chain(\r\n                  T.fromOption(constant(makeParentElementNotFound(target)))\r\n                ),\r\n                T.map((parent) => parent.getAttribute(\"data-todo-id\")),\r\n                T.map(O.fromNullable),\r\n                T.chain(\r\n                  T.fromOption(constant(makeParentElementNotFound(target)))\r\n                ),\r\n                T.map(Number),\r\n                T.chain((todoId) =>\r\n                  store.next((todos) =>\r\n                    todos.filter((todo) => todo.id !== todoId)\r\n                  )\r\n                ),\r\n                S.encaseEffect\r\n              );\r\n            }\r\n\r\n            return S.encaseEffect(T.pure(constVoid()));\r\n          }),\r\n          S.drain\r\n        )\r\n      )\r\n    )\r\n  ),\r\n  T.forever\r\n);\r\n","import * as serviceWorker from \"./serviceWorker\";\nimport \"./index.scss\";\n\nimport { effect as T } from \"@matechs/effect\";\nimport { provideConsole } from \"@matechs/console\";\n\nimport { pipe } from \"fp-ts/lib/pipeable\";\n\nimport * as Todo from \"./modules/todo\";\nimport { provideDom } from \"./modules/dom\";\nimport { provideDocument } from \"./modules/document\";\nimport * as Fetch from \"./modules/fetch\";\n\nimport { makeEmitterLive } from \"./modules/emitter\";\n\n\nconst provided = pipe(\n    // Run the main todo program\n  Todo.main,\n  // Provide DOM utilities\n  provideDom,\n  // Provide document object\n  provideDocument,\n  // Provide window.fetch\n  Fetch.provideFetch,\n  // Provide logging capabilities\n  provideConsole,\n  // Provide event emitter with root element\n  T.provide(makeEmitterLive(document)),\n  // Provide depracated thing\n  T.provide({\n    [T.AsyncRTURI]: {},\n  }),\n);\n\nT.runToPromise(provided)\n  .then((foo) => console.log(\"Done\", foo))\n  .catch((error) => {\n    console.error(error);\n  });\n  \n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}