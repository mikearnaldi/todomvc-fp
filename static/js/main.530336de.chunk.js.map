{"version":3,"sources":["serviceWorker.ts","modules/dom.ts","modules/fetch.ts","modules/store.ts","modules/emitter.ts","modules/document.ts","modules/todo.ts","index.ts"],"names":["Boolean","window","location","hostname","match","eventType","input","init","tagName","options","initial","rootEl","uri","subscribe","type","ret","el","S","fromSource","M","managed","chain","bracket","T","accessM","_","sync","su","queueUtils","next","ops","hasCB","unsubscribe","addEventListener","fromEvent","fn","a","_tag","emitter","documentLive","document","provideDocument","provide","getDocument","flow","pure","domLive","createElement","provideDom","ElementNotFound","selectors","name","Error","ParentElementNotFound","child","makeElementNotFound","makeParentElementNotFound","raiseError","element","toString","querySelector","O","$","pipe","map","fromOption","constant","parentElement","node","EmptyOptionOfElement","message","fetchLive","fetch","args","Promise","resolve","setTimeout","bind","provideFetch","FetchFailed","info","makeFetchFailed","url","error","todoDecoder","t","id","userId","title","completed","todosDecoder","fetchTodos","async","r","then","response","json","E","cb","decode","fromEither","_div","todosStore","Q","unboundedQueue","zip","ref","makeRef","queue","state","f","update","current","offer","subject","take","s","createTodoLi","innerHTML","todosUl","clearTodosUl","ul","renderTodos","todos","A","todo","todoLi","Do","return","label","checkbox","setAttribute","classList","add","checked","value","identity","updateTodoLi","sequence","effect","list","forEach","li","appendChild","main","store","parZip","fork","stream","encaseEffect","drain","loadTodos","target","todoIdT","div","parent","getAttribute","Number","todoId","tuple","hasAttribute","filter","addClass","removeClass","remove","focus","select","blur","save","event","key","trim","race","constVoid","clickStream","provided","Todo","Fetch","provideConsole","e","stopPropagation","removeEventListener","runToPromise","foo","console","log","catch","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.530336de.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL || '',\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import { effect as T, stream as S } from \"@matechs/effect\";\r\nimport * as O from \"fp-ts/lib/Option\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { constant, flow, identity } from \"fp-ts/lib/function\";\r\nimport { subscribe, Emitter, EventFor } from \"./emitter\";\r\nimport { DocumentEnv, getDocument } from \"./document\";\r\n\r\n/**\r\n * Environment\r\n */\r\nexport const uri = \"@uri/dom\";\r\n\r\nexport interface Dom {\r\n  [uri]: {\r\n    createElement<K extends keyof HTMLElementTagNameMap>(\r\n      tagName: K,\r\n      options?: ElementCreationOptions\r\n    ): HTMLElementTagNameMap[K];\r\n    createElement(\r\n      tagName: string,\r\n      options?: ElementCreationOptions\r\n    ): HTMLElement;\r\n  };\r\n}\r\n\r\nexport const domLive: Dom = {\r\n  [uri]: {\r\n    createElement: (tagName: any, options?: ElementCreationOptions) =>\r\n      document.createElement(tagName, options),\r\n  },\r\n};\r\n\r\nexport const provideDom = T.provide(domLive);\r\n\r\n/**\r\n * Errors\r\n */\r\nclass ElementNotFound extends Error {\r\n  constructor(selectors: string) {\r\n    super(`$(${selectors}) did not return an element.`);\r\n    this.name = \"ElementNotFound\";\r\n  }\r\n}\r\n\r\nclass ParentElementNotFound extends Error {\r\n  constructor(child: string) {\r\n    super(`Parent of node: ${child} not found.`);\r\n    this.name = \"ParentElementNotFound\";\r\n  }\r\n}\r\n\r\nexport const makeElementNotFound = (selectors: string) =>\r\n  new ElementNotFound(selectors);\r\n\r\nexport const raiseElementNotFound = flow(makeElementNotFound, T.raiseError);\r\n\r\nexport const makeParentElementNotFound = (element: HTMLElement) =>\r\n  new ParentElementNotFound(element.toString());\r\n\r\nexport const raiseParentElementNotFound = flow(\r\n  makeParentElementNotFound,\r\n  T.raiseError\r\n);\r\n\r\n/**\r\n * Utilities\r\n */\r\ninterface CreateElement {\r\n  <K extends keyof HTMLElementTagNameMap>(\r\n    tagName: K,\r\n    options?: ElementCreationOptions\r\n  ): T.Effect<unknown, Dom, never, HTMLElementTagNameMap[K]>;\r\n  (tagName: string, options?: ElementCreationOptions): T.Effect<\r\n    unknown,\r\n    Dom,\r\n    never,\r\n    HTMLElement\r\n  >;\r\n}\r\n\r\nexport const createElement: CreateElement = (\r\n  tagName: string,\r\n  options?: ElementCreationOptions\r\n) => T.accessM((_: Dom) => T.pure(_[uri].createElement(tagName, options)));\r\n\r\n/**\r\n * QuerySelector\r\n */\r\ninterface QuerySelector {\r\n  <K extends keyof HTMLElementTagNameMap>(selectors: K): <\r\n    TNode extends ParentNode\r\n  >(\r\n    node: TNode\r\n  ) => O.Option<HTMLElementTagNameMap[K]>;\r\n  <K extends keyof SVGElementTagNameMap>(selectors: K): <\r\n    TNode extends ParentNode\r\n  >(\r\n    node: TNode\r\n  ) => O.Option<SVGElementTagNameMap[K]>;\r\n  <E extends Element = Element>(selectors: string): <TNode extends ParentNode>(\r\n    node: TNode\r\n  ) => O.Option<E>;\r\n}\r\n\r\ninterface QuerySelectorT {\r\n  <K extends keyof HTMLElementTagNameMap>(selectors: K): <\r\n    TNode extends ParentNode\r\n  >(\r\n    node: O.Option<TNode>\r\n  ) => O.Option<HTMLElementTagNameMap[K]>;\r\n  <K extends keyof SVGElementTagNameMap>(selectors: K): <\r\n    TNode extends ParentNode\r\n  >(\r\n    node: O.Option<TNode>\r\n  ) => O.Option<SVGElementTagNameMap[K]>;\r\n  <E extends Element = Element>(selectors: string): <TNode extends ParentNode>(\r\n    node: O.Option<TNode>\r\n  ) => O.Option<E>;\r\n}\r\n\r\nexport const querySelector: QuerySelector = (selectors: string) => <\r\n  TNode extends ParentNode\r\n>(\r\n  el: TNode\r\n) => O.fromNullable(el.querySelector(selectors));\r\n\r\nexport const querySelectorO: QuerySelectorT = (selectors: string) => <\r\n  TNode extends ParentNode\r\n>(\r\n  nodeOT: O.Option<TNode>\r\n) =>\r\n  pipe(\r\n    nodeOT,\r\n    O.map((el) => querySelector(selectors)(el))\r\n  );\r\n\r\n/**\r\n * $\r\n */\r\ninterface $ {\r\n  <K extends keyof HTMLElementTagNameMap>(selectors: K): T.Effect<\r\n    unknown,\r\n    DocumentEnv,\r\n    ElementNotFound,\r\n    HTMLElementTagNameMap[K]\r\n  >;\r\n  <K extends keyof SVGElementTagNameMap>(selectors: K): T.Effect<\r\n    unknown,\r\n    DocumentEnv,\r\n    ElementNotFound,\r\n    SVGElementTagNameMap[K]\r\n  >;\r\n  <E extends Element = Element>(selectors: string): T.Effect<\r\n    unknown,\r\n    DocumentEnv,\r\n    ElementNotFound,\r\n    E\r\n  >;\r\n}\r\n\r\nexport const $: $ = (selectors: string) =>\r\n  pipe(\r\n    getDocument,\r\n    T.map(querySelector(selectors)),\r\n    T.chain(T.fromOption(constant(makeElementNotFound(selectors))))\r\n  );\r\n\r\n/**\r\n * ```hs\r\n * parentElement :: Node -> Option<HTMLelement>\r\n * ```\r\n */\r\nexport const parentElement = <TNode extends Node, TParentNode extends Node>(\r\n  node: TNode\r\n) => O.fromNullable(node.parentElement as TParentNode | null);\r\n\r\nexport class EmptyOptionOfElement extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = \"EmptyOptionOfElement\";\r\n  }\r\n}\r\n\r\nexport const raiseEmptyOptionOfElement = (message: string) =>\r\n  T.raiseError(new EmptyOptionOfElement(message));\r\n\r\nexport const makeEventStream = <TEventType extends string>(\r\n  eventType: TEventType\r\n) => <\r\n  R,\r\n  E,\r\n  A extends Pick<Element, \"addEventListener\" | \"removeEventListener\">\r\n>(\r\n  elementT: T.Effect<unknown, R, E, O.Option<A>>\r\n) =>\r\n  pipe(\r\n    elementT,\r\n    T.map((elementO) =>\r\n      pipe(\r\n        elementO,\r\n        O.map(subscribe(eventType)),\r\n        (effect) => effect,\r\n        O.fold<\r\n          S.Stream<unknown, Emitter, never, EventFor<TEventType>>,\r\n          S.Stream<unknown, Emitter, EmptyOptionOfElement, EventFor<TEventType>>\r\n        >(\r\n          constant(\r\n            S.raised(\r\n              new EmptyOptionOfElement(\r\n                `Option does not contain some element to create ${eventType} event stream for`\r\n              )\r\n            )\r\n          ),\r\n          identity\r\n        )\r\n      )\r\n    )\r\n  );\r\n\r\nexport const makeClickStream = makeEventStream(\"click\");\r\n","import { effect as T } from \"@matechs/effect\";\r\nimport * as E from \"fp-ts/lib/Either\";\r\nimport { flow } from \"fp-ts/lib/function\";\r\n\r\nexport const uri = \"@uri/fetch\";\r\n\r\nexport interface Fetch {\r\n  [uri]: {\r\n    fetch: typeof window.fetch;\r\n  }\r\n}\r\n\r\nexport const fetchLive: Fetch = {\r\n  [uri]: {\r\n    fetch: (...args) => new Promise(resolve => {\r\n      setTimeout(() => {\r\n        resolve(window.fetch.bind(window)(...args))\r\n      }, 2000)\r\n    })\r\n  },\r\n};\r\n\r\nexport const provideFetch = T.provide(fetchLive)\r\n\r\nclass FetchFailed extends Error {\r\n    constructor(info: string) {\r\n      super(`Unable to fetch: ${info}`);\r\n      this.name = \"FetchFailed\";\r\n    }\r\n  }\r\n\r\nconst makeFetchFailed = (url: string) => (error: string) => new FetchFailed(\r\n    `Fetching data from `\r\n)\r\n\r\nexport const fetch = (input: RequestInfo, init?: RequestInit) =>\r\n  T.accessM((_: Fetch) =>\r\n    T.async<FetchFailed, Response>((r) => {\r\n      try {\r\n        _[uri].fetch(input, init).then(response => response.json()).then(flow(E.right, r));\r\n      } catch (error) {\r\n        r(E.left(makeFetchFailed(typeof input === 'string' ? input : input.url)(error)));\r\n      }\r\n\r\n      return (cb) => {\r\n        cb(makeFetchFailed(typeof input === 'string' ? input : input.url)(\"\"));\r\n      };\r\n    })\r\n  );\r\n","import {\r\n  effect as T,\r\n  ref,\r\n  stream as S,\r\n  queue as Q,\r\n  managed as M,\r\n} from \"@matechs/effect\";\r\nimport { subject } from \"@matechs/effect/lib/stream\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport * as O from \"fp-ts/lib/Option\";\r\n\r\nexport interface Store<A> {\r\n  next: (f: (current: A) => A) => T.Effect<unknown, unknown, never, void>;\r\n  interrupt: T.Effect<unknown, unknown, never, void>;\r\n  subscribe: T.Sync<S.Stream<unknown, unknown, never, A>>;\r\n}\r\n\r\nexport const store = <A>(initial?: A) =>\r\n  pipe(\r\n    Q.unboundedQueue<A>(),\r\n    T.zip(ref.makeRef(initial ? [initial] : [])),\r\n    T.chain(([queue, state]) => {\r\n      const next = (f: (current: A) => A) =>\r\n        pipe(\r\n          state.update(([current]) => [f(current)]),\r\n          T.chain(([a]) => queue.offer(a))\r\n        );\r\n\r\n      return pipe(\r\n        subject(S.fromSource(M.pure(pipe(queue.take, T.map(O.some))))),        \r\n        T.map((s): Store<A> => ({ ...s, next }))\r\n      );\r\n    })\r\n  );\r\n","import { effect as T, stream as S, managed as M } from \"@matechs/effect\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { log } from \"@matechs/console\";\r\n\r\nexport const uri = \"@uri/emitter\";\r\n\r\nexport type EventFor<TEventType extends string> = TEventType extends\r\n  | \"keypress\"\r\n  | \"keyup\"\r\n  | \"keydown\"\r\n  ? KeyboardEvent\r\n  : TEventType extends \"click\" | \"dblclick\" | \"mousemove\" | \"mousedown\" | \"mouseup\"\r\n  ? MouseEvent\r\n  : Event;\r\n\r\nexport type EventHandler<TEventType extends string> = (\r\n  evt: EventFor<TEventType>\r\n) => void;\r\n\r\nexport interface Emitter {\r\n  [uri]: {\r\n    fromEvent: <TEventType extends string>(\r\n      type: TEventType\r\n    ) => (cb: EventHandler<TEventType>) => T.Effect<unknown, unknown, never, void>;\r\n    addEventListener: <TElement extends Pick<Element, 'addEventListener' | 'removeEventListener'>>(\r\n      el: TElement\r\n    ) => <TEventType extends string>(\r\n      type: TEventType\r\n    ) => (cb: EventHandler<TEventType>) => T.Effect<unknown, unknown, never, void>;\r\n  };\r\n}\r\n\r\n// Events\r\nexport const subscribe = <TEventType extends string>(type: TEventType, ret?: any) => <\r\n  TElement extends  Pick<Element, 'addEventListener' | 'removeEventListener'>\r\n>(\r\n  el?: TElement\r\n) => {\r\n  return S.fromSource(\r\n    M.managed.chain(\r\n      M.bracket(\r\n        T.accessM((_: Emitter) =>\r\n          T.sync(() => {\r\n            const { next, ops, hasCB } = S.su.queueUtils<\r\n              never,\r\n              EventFor<TEventType>\r\n            >();\r\n\r\n            const fn = el ? _[uri].addEventListener(el) : _[uri].fromEvent;\r\n\r\n            return {\r\n              unsubscribe: fn(type)(a => {\r\n                next({ _tag: \"offer\", a })\r\n                return ret\r\n              }),\r\n              ops,\r\n              hasCB\r\n            };\r\n          })\r\n        ),\r\n        _ => _.unsubscribe\r\n      ),\r\n      ({ ops, hasCB }) => S.su.emitter(ops, hasCB)\r\n    )\r\n  );\r\n};\r\n\r\nexport const makeEmitterLive = <\r\n  TRoot extends Pick<Element, \"addEventListener\" | \"removeEventListener\">\r\n>(\r\n  rootEl: TRoot\r\n): Emitter => {\r\n  return {\r\n    [uri]: {\r\n      fromEvent: <TEventType extends string>(type: TEventType) => (\r\n        cb: EventHandler<TEventType>\r\n      ) => {\r\n        const wrappedCb = (e: EventFor<TEventType>) => {\r\n          e.stopPropagation();\r\n          return cb(e);\r\n        };\r\n        rootEl.addEventListener(type, wrappedCb as any);\r\n\r\n        return T.sync(() => rootEl.removeEventListener(type, cb as any));\r\n      },\r\n      addEventListener: <TElement extends Pick<Element, 'addEventListener' | 'removeEventListener'>>(el: TElement) => <\r\n        TEventType extends string\r\n      >(\r\n        type: TEventType\r\n      ) => (cb: EventHandler<TEventType>) => {\r\n        const wrappedCb = (e: EventFor<TEventType>) => {\r\n          e.stopPropagation();\r\n          return cb(e);\r\n        };\r\n        el.addEventListener(type, wrappedCb as any);\r\n\r\n        return T.sync(() => el.removeEventListener(type, cb as any));\r\n      }\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * waitForKeyPress :: number -> Effect NoEnv never void\r\n *\r\n * Given a keyCode returns an effect that resolves once the user\r\n * presses a key on the keyboard matching the key code.\r\n */\r\nexport const waitForKeyPress = (...keyCodes: number[]) =>\r\n  T.effect.chain(log(\"Waiting for \", ...keyCodes), () =>\r\n    pipe(\r\n      subscribe(\"keyup\")(),\r\n      S.filter(event => keyCodes.includes(event.keyCode)),\r\n      S.take(1),\r\n      S.collectArray,\r\n      T.map(([evt]) => evt)\r\n    )\r\n  );\r\n","import { effect as T } from \"@matechs/effect\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport {  flow } from \"fp-ts/lib/function\";\r\n\r\nexport const documentUri = \"@uri/document\";\r\n\r\nexport type DocumentEnv = { [documentUri]: Document };\r\n\r\nexport const documentLive = {\r\n  [documentUri]: document,\r\n};\r\n\r\nexport const provideDocument = T.provide(documentLive);\r\n\r\nexport const getDocument = T.accessM(\r\n  flow((_: DocumentEnv) => _[documentUri], T.pure)\r\n);\r\n\r\nexport const mapDocument = <R, E, A>(f: (doc: Document) => T.Effect<unknown, R, E, A>) =>\r\n  pipe(getDocument, T.map(f));\r\n","import { effect as T, stream as S } from \"@matechs/effect\";\r\n\r\nimport * as O from \"fp-ts/lib/Option\";\r\nimport * as A from \"fp-ts/lib/Array\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { constant, identity, flow, constVoid, tuple } from \"fp-ts/lib/function\";\r\n\r\nimport * as t from \"io-ts\";\r\nimport { Do } from \"fp-ts-contrib/lib/Do\";\r\n\r\nimport {\r\n  createElement,\r\n  querySelector,\r\n  makeElementNotFound,\r\n  $,\r\n  parentElement,\r\n  makeParentElementNotFound,\r\n} from \"./dom\";\r\nimport * as Fetch from \"./fetch\";\r\nimport { subscribe } from \"./emitter\";\r\nimport { store, Store } from \"./store\";\r\nimport { completed } from \"@matechs/effect/lib/effect\";\r\n\r\n/**\r\n * ```hs\r\n *\r\n * URL :: string\r\n *\r\n * ```\r\n *\r\n * API URL where a list of todo objects is requested from\r\n */\r\nconst URL = \"https://jsonplaceholder.typicode.com/todos\";\r\n\r\n/**\r\n * ```hs\r\n *\r\n * Todo :: t.TypeC<Todo>\r\n *\r\n * ```\r\n *\r\n * io-ts decoder for Todo\r\n */\r\nconst todoDecoder = t.type(\r\n  {\r\n    id: t.number,\r\n    userId: t.number,\r\n    title: t.string,\r\n    completed: t.boolean,\r\n  },\r\n  \"Todo\"\r\n);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * Todos :: t.TypeC<Todos>\r\n *\r\n * ```\r\n *\r\n * io-ts decoder for a list of [[Todo]]\r\n */\r\nconst todosDecoder = t.array(todoDecoder);\r\n\r\n// Types\r\nexport type Todo = t.TypeOf<typeof todoDecoder>;\r\n\r\nexport type Todos = t.TypeOf<typeof todosDecoder>;\r\n\r\n// APIS\r\nexport const fetchTodos = pipe(\r\n  // Fetch list of todos from the server\r\n  Fetch.fetch(URL),\r\n  // Decode the response\r\n  T.chain((response) => T.sync(() => todosDecoder.decode(response))),\r\n  // From Effect<R, E, Either<E2, Todos> to Effect<R, E | E2, Todos>\r\n  T.chain(T.fromEither)\r\n);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * html :: string\r\n *\r\n * ```\r\n *\r\n * HTML used to create a todo for\r\n */\r\nconst html = `<li>\r\n    <div class=\"view\">\r\n        <input data-toggle class=\"toggle\" type=\"checkbox\">\r\n        <label data-edit>Buy a unicorn</label>\r\n        <button data-remove class=\"destroy\"></button>\r\n    </div>\r\n    <input class=\"edit\" value=\"Rule the web\">\r\n</li>`;\r\n\r\n// TODO: Use environment to produce div\r\nconst _div = createElement(\"div\");\r\n\r\n/**\r\n * ```hs\r\n *\r\n * todosStore :: Effect unknown never (Store Todos)\r\n *\r\n * ```\r\n *\r\n * You can update the list of todos by passing a callback function to store.next\r\n * or subscribe to store changes using the store.subscribe stream.\r\n */\r\nexport const todosStore = store<Todos>();\r\n\r\n/**\r\n * ```hs\r\n *\r\n * createTodoLi :: Effect Dom ElementNotFound HTMLLIElement\r\n *\r\n * ```\r\n *\r\n * Create a dom element for a todo\r\n */\r\nexport const createTodoLi = pipe(\r\n  _div,\r\n  T.chain((el) =>\r\n    T.sync(() => {\r\n      el.innerHTML = html;\r\n      return querySelector(\"li\")(el);\r\n    })\r\n  ),\r\n  T.chain(\r\n    T.fromOption(\r\n      constant(\r\n        makeElementNotFound(\"Unable to create DOM element for todo item.\")\r\n      )\r\n    )\r\n  )\r\n);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * todosUl :: Effect DocumentEnv ElementNotFound HTMLUListElement\r\n *\r\n * ```\r\n *\r\n * Select the ul dom node that contains the list of li nodes that are todo items.\r\n */\r\nexport const todosUl = $<HTMLUListElement>(\".todo-list\");\r\n\r\nexport const clearTodosUl = pipe(\r\n  todosUl,\r\n  T.chain((ul) =>\r\n    T.sync(() => {\r\n      ul.innerHTML = \"\";\r\n    })\r\n  )\r\n);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * updateTodoLi :: Todo -> HTMLLIElement -> Effect unknown Error HTMLLIElement\r\n *\r\n * ```\r\n *\r\n * Update a given todo dom li node with information from a [[Todo]] model\r\n */\r\nexport const updateTodoLi = (todo: Todo) => (todoLi: HTMLLIElement) =>\r\n  pipe(\r\n    Do(O.option)\r\n      // Select the input and label dom nodes that are inside the li node\r\n      .bind(\"label\", querySelector(\"label\")(todoLi))\r\n      .bind(\"checkbox\", querySelector(\"input\")(todoLi))\r\n      .bind(\"input\", querySelector<HTMLInputElement>(\"input.edit\")(todoLi))\r\n      .return(({ label, checkbox, input }) =>\r\n        T.sync(() => {\r\n          // Update title\r\n          label.innerHTML = todo.title;\r\n\r\n          // Add todo id as attribute\r\n          todoLi.setAttribute(\"data-todo-id\", \"\" + todo.id);\r\n\r\n          // Mark as completed if so\r\n          todo.completed && todoLi.classList.add(\"completed\");\r\n          checkbox.checked = todo.completed;\r\n          input.value = todo.title\r\n\r\n          return todoLi;\r\n        })\r\n      ),\r\n    // TODO: Handle if label or input aren't available\r\n    T.fromOption(constant(Error(\"\"))),\r\n    T.chain(identity)\r\n  );\r\n\r\n/**\r\n * ```hs\r\n *\r\n * renderTodos :: [Todo] -> Effect (DocumentEnv & Dom) (Error | ElementNotFound) (void, HTMLUListElement)\r\n *\r\n * ```\r\n *\r\n * Clear the ul dom node and re-render the list of li todo items.\r\n *\r\n */\r\nexport const renderTodos = (todos: Todos) =>\r\n  T.zip(\r\n    pipe(\r\n      todos,\r\n      A.map((todo) => pipe(createTodoLi, T.chain(updateTodoLi(todo)))),\r\n      A.array.sequence(T.effect),\r\n      T.chain((list) =>\r\n        pipe(\r\n          $<HTMLUListElement>(\".todo-list\"),\r\n          T.chain((ul) =>\r\n            T.sync(() => {\r\n              list.forEach((li) => ul.appendChild(li));\r\n              return ul;\r\n            })\r\n          )\r\n        )\r\n      )\r\n    )\r\n  )(clearTodosUl);\r\n\r\n\r\nconst clickStream = (store: Store<Todos>) => pipe(\r\n  // With the dom node that is the lisf items\r\n  todosUl,\r\n  S.encaseEffect,\r\n  // Subscribe to clicking the list\r\n  S.chain(\r\n    pipe(\r\n      subscribe(\"click\"), \r\n    )\r\n  ),\r\n  // Map the mouse event to the target (currentTarget would be the list, we want what the user actually clicked.)\r\n  S.map((_) => _.target),\r\n  S.map(O.fromNullable),\r\n  S.chain(S.fromOption),\r\n  S.chain((_) => {\r\n    const target = _ as HTMLElement;\r\n\r\n    const todoIdT = pipe(\r\n      parentElement<HTMLElement, HTMLDivElement>(target),\r\n      O.chain((div) =>\r\n        parentElement<HTMLDivElement, HTMLLIElement>(div)\r\n      ),\r\n      T.pure,\r\n      T.chain(\r\n        T.fromOption(constant(makeParentElementNotFound(target)))\r\n      ),\r\n      T.map((parent) => pipe(\r\n        parent.getAttribute(\"data-todo-id\"),\r\n        O.fromNullable,\r\n        O.map(Number),\r\n        O.map(todoId => tuple(todoId, parent))\r\n      )),\r\n      T.chain(\r\n        T.fromOption(constant(makeParentElementNotFound(target)))\r\n      ),\r\n    );\r\n\r\n    // If the clicked the remove button\r\n    if (target.hasAttribute(\"data-remove\")) {\r\n      return pipe(\r\n        todoIdT,\r\n        T.chain(([todoId]) =>\r\n          store.next((todos) =>\r\n            todos.filter((todo) => todo.id !== todoId)\r\n          )\r\n        ),\r\n        S.encaseEffect\r\n      );\r\n    } else if (target.hasAttribute(\"data-toggle\")) {\r\n      return pipe(\r\n        todoIdT,\r\n        T.chain(([todoId]) =>\r\n          store.next((todos) =>\r\n            todos.map((todo) => todo.id === todoId ? {...todo, completed: !todo.completed} : todo)\r\n          )\r\n        ),\r\n        S.encaseEffect\r\n      );\r\n    } else if (target.hasAttribute(\"data-edit\")) {\r\n      return pipe(\r\n        todoIdT,\r\n        T.chain(([todoId, li]) => {\r\n          const addClass = T.sync(() => {\r\n            li.classList.add('editing')\r\n          });\r\n\r\n          const removeClass = T.sync(() => {\r\n            li.classList.remove('editing')\r\n          })\r\n\r\n          const input = pipe(\r\n            li,\r\n            querySelector<HTMLInputElement>('input.edit'),\r\n            T.fromOption(constant(makeElementNotFound('li>input'))),\r\n            T.chain(input => {\r\n              const focus = T.sync(() => { \r\n                input.focus();\r\n                input.select()\r\n               })\r\n\r\n               const blur = pipe(\r\n                 input,\r\n                 subscribe('blur'),\r\n                 S.take(1),\r\n                 S.drain,\r\n                 T.zip(removeClass)\r\n               )\r\n\r\n               const save = pipe(\r\n                 input,\r\n                 subscribe('keyup'),\r\n                 S.filter(event => event.key === 'Enter' && !!input.value.trim()),\r\n                 S.take(1),\r\n                 S.drain,\r\n                 T.chain(constant(\r\n                  store.next((todos) =>\r\n                    todos.map((todo) => todo.id === todoId ? {...todo, title: input.value } : todo)\r\n                  )\r\n                 )),\r\n                 T.zip(removeClass)\r\n               )\r\n\r\n               return pipe(\r\n                 focus,\r\n                 T.zip(T.race(blur, save))\r\n               )\r\n            })\r\n          )\r\n\r\n          return pipe(\r\n            addClass,\r\n            T.zip(input),\r\n          )\r\n        }\r\n  \r\n        ),\r\n        S.encaseEffect\r\n      );\r\n    }\r\n\r\n    return S.encaseEffect(T.pure(constVoid()));\r\n  }),\r\n  S.drain\r\n)\r\n\r\nconst loadTodos = (store: Store<Todos>) => pipe(\r\n  // Fetch todos from the sever\r\n  fetchTodos,\r\n  // Put items in the store\r\n  T.chain(flow(constant, store.next)),\r\n  // Fork fetching todos\r\n  T.fork,\r\n  T.chain(\r\n    constant(\r\n      pipe(\r\n        // Subscribe to the store\r\n        store.subscribe,\r\n        T.chain((stream) =>\r\n          pipe(\r\n            stream,\r\n            // Only take 10 items at a time\r\n            S.map((list) => pipe(list, A.takeLeft(10))),\r\n            // Update the DOM\r\n            S.chain(flow(renderTodos, S.encaseEffect)),\r\n            S.drain\r\n          )\r\n        )\r\n      )\r\n    )\r\n  )\r\n)\r\n\r\n/**\r\n * The main event\r\n */\r\nexport const main = pipe(\r\n  pipe(\r\n    // Use the store\r\n    todosStore,\r\n    T.chain((store) =>\r\n      T.parZip(\r\n        // Fetch todos and subscribe to the store for updates and re-render\r\n       loadTodos(store),\r\n       clickStream(store)\r\n      )\r\n    )\r\n  )\r\n);\r\n","import * as serviceWorker from \"./serviceWorker\";\nimport \"./index.scss\";\n\nimport { effect as T } from \"@matechs/effect\";\nimport { provideConsole } from \"@matechs/console\";\n\nimport { pipe } from \"fp-ts/lib/pipeable\";\n\nimport * as Todo from \"./modules/todo\";\nimport { provideDom } from \"./modules/dom\";\nimport { provideDocument } from \"./modules/document\";\nimport * as Fetch from \"./modules/fetch\";\n\nimport { makeEmitterLive } from \"./modules/emitter\";\n\n\nconst provided = pipe(\n    // Run the main todo program\n  Todo.main,\n  // Provide DOM utilities\n  provideDom,\n  // Provide document object\n  provideDocument,\n  // Provide window.fetch\n  Fetch.provideFetch,\n  // Provide logging capabilities\n  provideConsole,\n  // Provide event emitter with root element\n  T.provide(makeEmitterLive(document)),\n  // Provide depracated thing\n  // T.provide({\n  //   [T.AsyncRTURI]: {},\n  // }),\n);\n\nT.runToPromise(provided)\n  .then((foo) => console.log(\"Done\", foo))\n  .catch((error) => {\n    console.error(error);\n  });\n  \n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}